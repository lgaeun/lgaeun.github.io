[ { "title": "🌀 Delve into TS environment - eslint, prettier, babel", "url": "/posts/delve-into-ts-environment/", "categories": "TIL", "tags": "typescript", "date": "2022-03-26 10:35:23 +0900", "snippet": "이번에 js 프로젝트를 ts로 바꾸는 강의를 들으면서 typescript 환경에 대해 궁금해져서 정리해 보게 되었다.ESlint code level에서 에러가 날 만한 부분을 짚어준다 문법오류체크, 자동완성, formatting 지원 .eslintrc.{js, yml, json} 여러가지 확장자로 할 수 있는데 js로 하면 주석 달 수 있어서 좋음module.exports = { root: true, //lint가 root:true라고 지정하면 이 위치까지만 configuration 파일들을 찾음 env: { //프로젝트의 사용 환경을 설정 browser: true, node: true, }, extends: [ 'eslint:recommended', //eslint의 기본 권장하는 옵션으로 validation 하겠음 'plugin:@typescript-eslint/eslint-recommended', 'plugin:@typescript-eslint/recommended', ], ignorePatterns: [\"temp.js\", \"**/vendor/*.js\"], //이 파일들은 건너뜀 plugins: ['react', 'prettier', '@typescript-eslint'], // rules: { 'prettier/prettier': [ //prettier 설정 - eslint-plugin-prettier 'error', //error level로 설정 { singleQuote: true, //prettier 관련 설정은 아래에서 설명 semi: true, useTabs: false, tabWidth: 2, printWidth: 80, bracketSpacing: true, arrowParens: 'avoid', }, ], }, parserOptions: { parser: '@typescript-eslint/parser', //ts파일을 파싱하기 위해 다음과 같은 parser를 사용하겠다. },};(1) extends 옵션: 상속받을 모든 파일 configuration file을 지정할 수 있음 여러 개는 array형식으로 적으면 됌 extends에서 기본적으로 따를 형식을 정해놓고, 이후에 ‘rules’ option에서 override 할 수 있음 eslint/recommended, eslint:all 이 있는데 후자는 잘 쓰지 않음(안 쓰는게 안전함) eslint-config prefix를 생략할 수 있음 // example extends: ['eslint-config-airbnb', 'eslint-config-standard'] extends: ['airbnb', 'standard']//위와 동일함 (2) rules 옵션: 규칙들을 override(또는 확장) 할 수 있음 \"rules\": { // enable additional rules \"indent\": [\"error\", 4], // indent 4 \"linebreak-style\": [\"error\", \"unix\"], \"quotes\": [\"error\", \"double\"], //double quote면 error로 \"semi\": [\"error\", \"always\"], //semi colon 항상 - 없으면 error // override configuration set by extending \"eslint:recommended\" \"no-empty\": \"warn\", \"no-cond-assign\": [\"error\", \"always\"], // disable rules from base configurations \"for-direction\": \"off\",} 아래처럼 객체형식으로 적어도 됌. array의 첫 번째 원소는 ‘error’처럼 적어도 되지만 숫자로 적어도 됌. 0=off, 1=warn, 2=error \"max-lines\": [\"error\", { \"max\": 100 }] \"react/jsx-filename-extension\": [2, { \"extensions\": [\".jsx\", \".tsx\"] }], (3) plugin 옵션: eslint에 추가하고 싶은 npm package 마찬가지로 eslint-plugin- prefix를 앞에 생략할 수 있음 ( react === eslint-plugin-react)그 외에 굉장히 많은 rule 들을 지정할 수 있는데 홈페이지 참고.그리고 prettier와 함께 쓰면 eslint 자체에서도 formatting하는 기능이 있기 때문에 conflict가 생긴다. 따라서 plugin들을 설치해서 eslint의 formatting을 disable해주고, prettier에게 모든 formatting을 일임해줄 수 있다. eslint-config-prettier: eslint의 prettier와 충돌나는 formatting 비활성화 eslint-plugin-prettier: prettier를 eslint에 plugin으로 추가해서 사용하기 위함추가로 prettier 공식 document에서는 eslint-plugin-prettier 플러그인을 사용하는 게 generally not recommended라고 다음과 같은 이유로 써있긴 하다.- 직접적으로 prettier을 돌렸을 때보다 느리다- 에러 라인이 너무 많아질 수 있다(?)Prettier보통 .prettierrc 파일을 추가해서 사용하면 되지만, eslint에 plugin 깔아서 거기서 설정해줘도 된다. 팀 단위 코딩 컨벤션을 정의할 때 사용하는 도구 보통 이정도 셋팅해두고, 팀에서 협의해서 추가/삭제하면 된다 { \"singleQuote\": true, // 문자열은 따옴표로 formatting \"semi\": true, //코드 마지막에 세미콜른이 있게 formatting \"useTabs\": false, //탭의 사용을 금하고 스페이스바 사용으로 대체하게 formatting \"tabWidth\": 2, // 들여쓰기 너비는 2칸 \"trailingComma\": 'all', // 객체나 배열 키:값 뒤에 항상 콤마를 붙히도록 formatting \"printWidth\": 120, // 코드 한줄이 maximum 120칸 \"arrowParens\": 'avoid', // 화살표 함수가 하나의 매개변수를 받을 때 괄호를 생략하게 formatting} Babel javascript compiler(최신 js 문법이 최대한 많은 브라우저에 호환될 수 있도록 바꿔주는 도구)referenceEslint configuration doc TS강의 - section.5 플젝 환경 구성 ESLint, Prettier 적용하기" }, { "title": "기본과 본질", "url": "/posts/booklog/", "categories": "인사이트, Booklog", "tags": "독서", "date": "2022-03-25 15:18:54 +0900", "snippet": "⌜유대인의 하루는 저녁 6시에 시작된다⌟-오인환 지음감상어느 순간부터 시간의 주인이 아니라 노예, 따지자면 솔거노비 쯤으로 살고 있다는 생각이 들고 나서 서점을 구경하다 이 책을 발견하고 덥석 사버렸다.이외에도 요즘 많은 책들을 읽었는데 주제는 달라도 공통적으로 하는 말이 있다. 본질이 중요하다.일의 본질, 시간의 본질, 공부의 본질, 독서의 본질 등.‘주’와 ‘부’를 구별하는 힘.우선순위와 핵심, 긴급도를 파악하는 능력.독서도 마찬가지다. 거의 300~400쪽이나 되는 페이지를 들여서 결국 말 하고자 하는 단 하나의 문장은 무엇인가, 어떤 이유에서 쓰였고, 어떤 방식으로 얘기하는가.본질 파악 뒤 가장 중요한 것은 당연히 실행력. 행동하지 않으면 아무 쓸모가 없다. 행동을 통한 결과는 신의 뜻이지만, 실행하는지 여부는 내가 바꿀 수 있는 것이다.이 책도 이 중 하나인 시간의 본질을 파악하는 것이 중요함을, 그리고 본질 파악 능력을 기르는 한 가지 방법으로 독서를 제시하고 있다.시간 관리의 핵심은 결국 생산성이다. 생산성은 ‘무엇’을 하느냐에 집중하는 것이 아니라 ‘왜’, ‘어떻게’, ‘얼마나’에 집중하는 것이다. 내가 시간 관리를 왜 하고 싶은지, 시간 관리를 통해 최종적으로 이루고자 하는 목표가 무엇인지가 다시 생각해보자.글 조각 우리는 매시간의 가치를 생각해야 한다. 시간의 가치를 안다는 의미는 곧 삶의 가치를 안다는 것과 같다. 모두가 비슷한 능력을 갖고 있고, 치열한 경쟁을 벌이고 있는 상황이라면 돈을 아끼는 것보다 시간을 아끼는 것이 훨씬 더 중요하다. 기본은 밑바닥에 있는 듯 하지만 전체를 바꾸는 힘이 있다. 평범한 사람과 천재를 구분할 수 있는 가장 분명한 기준은 ‘라이프 스타일’이다. 아침에 눈을 뜨자마자 습관적으로 어떤 행위를 하고 있는지, 사람을 기다리는 자투리 시간 동안에도 남들과 달리 어떤 행동을 하는지를 보면 차이가 분명하게 드러난다. 인생을 바꾸는 거대한 변화는 사실상 자투리 시간 같은 작은 시간이 쌓여 이루어진다. 심플함은 가장 실용적인 것이다. 디자인이나 미술과 같은 예술 분야에서는 완벽함이란 더 이상 뺄 것이 없는 상태를 말한다고 한다. 삶을 단순화하고 머릿속을 비워 편안하게 만드는 것은 통찰력을 기를 수 있고, 통찰력은 본질을 파악하는 데 있어서 중요한 역할을 한다. 지금 우리게 중요한 것은 얼마나 시간을 더 쪼개어 잘게 사용하느냐가 아닐라 오히려 비우고 줄이고 단순화하는 작업이 아닐까." }, { "title": "🌀 TS strict 적용하기", "url": "/posts/ts-strict/", "categories": "TIL", "tags": "typescript", "date": "2022-03-24 10:35:23 +0900", "snippet": "Prerequisitetsconfig.json\"strict\": true요런 family option들 모두에 대해 강한 타입 체크를 해주는 옵션이다.1. Null 타입 오류 및 함수 타입 오류 해결Strict Null Checkfunction initEvents() { rankList.addEventListener('click', handleListClick);}rankList에 대한 null check가 필요하다. 따라서 initEvents 함수 최상단에 다음과 같은 Null check를 넣어줌으로써 해결한다. if (!rankList) { return; }Strict Function Type Checkfunction의 argument type에 대해서도 정확하게 맞춰주어야 한다. 물론 tsconfig.json에서 ‘strictFunctionTypes:false’를 하며 에러가 사라지긴 한다.예를 들어 handleClick이란 함수가 있고, 이걸 something에 addEventListener로 추가하려고 할 때 오류가 발생한다.something.addEventListener('click', handleClick)async function handleClick(event: MouseEvent) {//...}에러 메시지를 차근차근 읽어보면 맨 끝에 이런 문구를 확인할 수 있는데event의 Type이 MouseClick인데 addEventListener의 콜백의 파라미터 타입이랑 호환이 불가능해서 그렇단다. 타입을 MouseEvent → Event로 바꿔주면 된다.여기서 배운점: 구글링을 잘 하기 전에 에러 메세지를 잘 확인하자. 구글링의 질을 높일 수 있다.2. 타입스크립트 내장 타입의 위계 구조DOM Element 타입 호환 관련해서 알고 있으면 유용할 것 같다.// hierarchy: a &gt; b &gt; c 순으로 높다.const a: Element;const b: HTMLElement;const c: HTMLDivElement;// hierarchy: ev1 &gt; ev2 &gt; ev3 순으로 높다.const ev1: Event;const ev2: UIEvent;const ev3: MouseEvent;3. 타입 단언을 이용한 타입 에러 해결recoveredList!.appendChild(li);recoveredList 오브젝트가 possibly null일 수 있기 때문에 에러가 나타나는데 이때 ‘!’를 뒤에 붙여서 non-null임을 명시해 해결해볼 수 있다.이런 타입 단언 시 주의점이 있는데interface Food{ type: string; price: number;}// type annotationconst sushi: Food = { type: Japanese; price: 18000;}// type assertionconst chicken = {} as Food;타입 단언의 경우 타입 에러가 뜨지는 않지만 이후에 초기값을 정하지 않음으로써 발생하는 오류의 원인이 될 수 있다.4. 옵셔널 체이닝 연산자1번에서처럼 possible null 타입에 대해 매번 체크해줘도 되지만 번거로우므로 다음과 같이 optional chainig을 쓰면 더 간결하다.recoveredList?.appendChild(li);5. DOM 유틸 함수 활용성을 높이는 타입 정의이전까지는 유틸함수를 아래와 같이 정의 해 사용하고 있었다.//utilfunction $(selector: string) { return document.querySelector(selector);}// DOMconst confirmedTotal = $('.confirmed-total') as HTMLSpanElement;아래와 같이 수정하면 더 간결해질 수 있고, 디폴트값을 정의함으로써 더 빠른 간결한 타입 추론이 가능하다.//util - using genericfunction $&lt;T extends HTMLElement = HTMLDivElement&gt;(selector: string) { const element = document.querySelector(selector); return element as T; // 리턴 타입에서 Null 없애기}// DOMconst confirmedTotal = $&lt;HTMLSpanElement&gt;('.confirmed-total');강의 끝!reference.https://www.typescriptlang.org/tsconfig#strict TS강의를 들으며 정리한 내용입니다." }, { "title": "🌀 Event, Axios type 정의", "url": "/posts/event-axios-type/", "categories": "TIL", "tags": "typescript", "date": "2022-03-23 12:32:01 +0900", "snippet": "파라미터 타입들 정의하기parameter, return value등에 대해 따로 빼서 interface나 type으로 정의해서 사용하면 된다.Event typefunction initEvents() { list.addEventListener('click', handleListClick);}async function handleListClick(event: any) { // ...}에서 click 이벤트이므로 MouseEvent로 바꿀 수 있다.async function handleListClick(event: MouseEvent) { // ...}이벤트 타입은 event위에 마우스를 올리면 알 수 있다.AxiosPromise를 리턴하는 함수는 Promise&lt;AxiosResponse« Type » 으로 정의해주면 된다. TS강의를 들으며 정리한 내용입니다." }, { "title": "🌀 3/16 TS - DOM 함수 타입 오류 해결하기 (ref. ts:2740)", "url": "/posts/DOM-element-type/", "categories": "TIL", "tags": "typescript", "date": "2022-03-16 12:35:23 +0900", "snippet": "DOM Element typefunction $(selector: string) { return document.querySelector(selector);}const confirmedTotal = $(\".confirmed-total\");const deathsTotal = $(\".deaths\");const recoveredTotal = $(\".recovered\");위와 같은 util 함수를 작성했을 때, 반환되는 타입은 Element인 것을 알 수 있다.querySelectyor로 가져온 DOM Element의 타입은 어떻게 될까?타입을 단언해주지 않으면 다음과 같은 메소드를 사용할 때 에러가 발생한다.deathsTotal.innerText = data[0].Cases; // error here(ts:2740)SolutionDOM element의 타입은 다음과 같이 extend될 수 있다. 따라서 tag의 종류에 따라 아래와 같이 type을 단언해주면 에러가 없어진다.// Dom Element의 type들var DomElement: Element | HTMLElement | HTMLParagraphElement;// wrong solution - 타입 간에 호환 할 수 없기 때문에 여전히 에러const confirmedTotal: HTMLSpanElement = $(\".confirmed-total\"); //&lt;span&gt;const deathsTotal: HTMLParagraphElement = $(\".deaths\"); //&lt;p&gt;const recoveredTotal: HTMLParagraphElement = $(\".recovered\"); //&lt;p&gt;// correct solutionconst confirmedTotal = $(\".confirmed-total\") as HTMLSpanElement; //&lt;span&gt;const deathsTotal = $(\".deaths\") as HTMLParagraphElement; //&lt;p&gt;const recoveredTotal = $(\".recovered\") as HTMLParagraphElement; //&lt;p&gt;또한 앞으로 as를 이용해 type 단언 해주는 경우가 많아지면 util함수로 저 부분을 빼서 코드를 더 깔끔하게 작성할 수도 있다. TS강의를 들으며 정리한 내용입니다." }, { "title": "☀️[모던] Ch-27. Javascript 배열 - (1) 개념 및 기본 메서드", "url": "/posts/js-array/", "categories": "TIL", "tags": "javascript, 모던자바스크립트", "date": "2022-03-15 12:27:09 +0900", "snippet": "자바스크립트 배열은 배열이 아니다.자바스크립트 배열은 사실 객체다.length와 index 프로퍼티를 갖고 있는, 일반적인 배열의 동작을 흉내 낸 특수한 객체다.자바스크립트에서 배열은 해시 테이블로 구현된 객체이므로 일반적인 배열보다 요소 접근이 느릴 수 있어도 삽입/삭제가 빠르다.어떤 타입의 값이라도 배열의 요소가 될 수 있고, 중간이 비어있을 수 있는 희소배열이다. 그렇지만 같은 타입으로 하는 게 좋다// example[].length // 0[1,2,3].length // 3[1, , 3] // 희소배열배열 메서드배열 메서드의 패턴은 두 가지가 있다. 원본 배열을 직접 변경한는 메서드 새로운 배열을 생성하여 반환하는 메서드원본 배열을 직접 변경하는 메서드는 외부 상태를 직접 변경하는 부수 효과가 있으므로, 가급적 원본 배열을 직접 변경하지 않는메서드를 사용하는 편이 좋다.   원본 배열 변경 새로운 배열 생성 ES6 (권장) 맨 앞 요소 제거 shift()     맨 앞 요소 추가 unshift(elem)   -&gt; spread 권장 맨 뒤 요소 제거 pop()     맨 뒤 요소 추가 push(elem) concat() -&gt; spread 권장 중간에 추가/제거/변경 splice()     그 외   권장 요소 존재 확인 indexOf(elem) -&gt; includes(elem) includes()를 사용하면 가독성이 높아지므로 사용 권장.또한 indexOf는 NaN이 배열에 포함되어 있는지 확인할 수 없음.[NaN].indexOf(NaN) !== -(1)[NaN].includes(NaN); // false // true그리고 일관성 있는 코드를 위해 웬만하면 다 spread operator 사용하는 것을 권장.Array.from//유사배열 객체를 반환하여 배열을 생성한다Array.from({ length: 2, 0: \"a\", 1: \"b\" }); // -&gt; ['a','b']Array.from(\"Hello\"); // -&gt; ['H', 'e', 'l','l','o']// 두 번째 인수로 전달한 콜백 함수의 반환값으로 구성된 배열을 반환한다.Array.from({ length: 3 }, (_, i) =&gt; i); // -&gt; [0, 1, 2]Array.splice(start, deleteCount, items) 원본배열 변경const arr = [1, 2, 3, 4];const result = arr.splice(1, 2, 20, 30); // [1, 20, 30, 4]const result1 = arr.splice(1, 0, 100); // [1, 100, 2, 3, 4]const result2 = arr.splice(1, 2); // [1, 4]const result3 = arr.splice(1); // [1]// vs. filterarr.filter((v) =&gt; v !== item); // -&gt; 해당되는 모든 요소를 제거한다const index = arr.indexOf(item);arr.splice(index, 1); // -&gt; 첫 번째로 해당되는 요소를 제거한다Array.slice(start, end) 원본 배열 변경X, 복사해서 리턴const arr = [1, 2, 3];arr.slice(0, 1); // [1]arr.slice(1, 2); // [2]arr.slice(1); // [1]arr.slice(-1); // [3]arr.slice(-2); //[2, 3]const copy = arr.slice(); //복사본을 생성하여 반환 (shallow copy)깊은 복사 vs 얕은 복사Array.join()arr.join(); //기본 구분자는 컴마(,)arr.join(\" \");arr.join(\":\");Array.reverse() 원본 배열을 변경arr.reverse();Array.fill() 초기화에 사용 오직 하나의 값으로 밖에 채울 수 없기 때문에 Array.from 메서드를 이용하면 여러 값들로 채울 수 있다.arr.fill(0); // 채울 값arr.fill(0, 1); // 1번 index부터 채우기arr.fill(0, 1, 3); // [1,3) index 채우기Array.includes(elem, (start))arr.includes(2);arr.includes(1, 1); 책 ‘모던 자바스크립트 Deep Dive’를 읽고 정리한 내용입니다." }, { "title": "[Jekyll] Chirpy theme - push시 blank page만 뜨는 이슈 해결해보기 ", "url": "/posts/Chipry-issue-fix/", "categories": "TIL", "tags": "jekyll", "date": "2022-03-14 15:27:09 +0900", "snippet": "서문원래 스케쥴러, 일기 등 무언가를 잘 적지 않는 편이지만 요즘 기록의 중요성을 실감했다. 이제부터 휘발성인 기억을 믿는다면 내가 바보다. 조리 있게 글을 잘 적는 편도 아니고 누군가가 내 글을 읽을 수 있다는 것이 아직은 부끄럽다. 그럼에도 정제가 덜 된 글이라도 일단 적기 시작해보려 한다. 그게 이 소소한 블로그를 다시 시작한 이유이다.근데 github에 push 후 {username}.github.io 에 들어가면 이렇게 빈 화면만 뜨는데..환장..화가 나버려..그렇지만 좌절하지 않는다.역시나 구글링으로 해결할 수 없는 문제는 없었다.해결 과정 또한 기록으로 남겨놓는다. (나와 같은 이슈를 겪은 사람들은 더 빨리 해결하기를..)해결방법 repository에서 브랜치명을 main -&gt; master로 변경한다. pages-deploy.yml에서도 마찬가지로 변경한다. 이 파일은 .github &gt; workflows 디렉토리 안에 있음. (없으면 tutorial 다시 읽고 생성해보길) name: \"Automatic build\"on:push: branches: - master # 이 부분을 main -&gt; master로 변경 paths-ignore: - .gitignore - README.md - LICENSE 우선 나는 chirpy-starter를 이용해 블로그를 구축하였는데, 이 때 default 브랜치명이 main으로 설정된다. Chirpy의 버그인지, 브랜치명이 main이면 제대로 동작하지 않고 반드시 master여야 하나보다. push를 하고 나면 gh-pages라는 브랜치가 생성되어 있다. repository setting &gt; Pages &gt; GitHub Pages 설정에 들어가서 다음과 같이 소스 브랜치를 gh-pages로 바꿔 주고 Save 버튼을 누르면 끝이다. 레퍼런스참고한 사이트1참고한 사이트2" }, { "title": "☀️ 3/13 React - contextAPI, useReducer", "url": "/posts/TIL-usereducer-contextAPI/", "categories": "TIL", "tags": "React", "date": "2022-03-13 09:32:00 +0900", "snippet": "ContextAPI props drilling을 방지하기 위한 방법 중 하나 1 context 1 content ⇒ 즉, 여러 데이터를 넘기기 위해서는 context를 데이터 갯수 만큼 생성하던가 객체를 value로 넘기기 (better!) contextAPI 자체는 state 관리가 아님. useState나 dispatch를 함께 사용한다면 상태관리가 될 수 있음. useContext를 이용해 클릭하면 커지는 원 구현하기import React, { useState, useContext } from \"react\";import logo from \"./logo.svg\";import \"./App.css\";const CircleSizeContext = React.createContext();function CircleSizeProvider(props) { const [circleSize, circleSizeChange] = useState(20); return ( &lt;CircleSizeContext.Provider value={{ circleSize, circleSizeChange }}&gt; {props.children} &lt;/CircleSizeContext.Provider&gt; );}function Circle() { const { circleSize, circleSizeChange } = useContext(CircleSizeContext); return ( &lt;div onClick={() =&gt; circleSizeChange(circleSize + 20)} style={{ width: circleSize + \"px\", height: circleSize + \"px\", borderRadius: \"50%\", background: \"red\", }} /&gt; );}function App() { return ( &lt;CircleSizeProvider&gt; &lt;div className=\"App\"&gt; &lt;h1&gt;Click circle&lt;/h1&gt; &lt;div style={{ display: \"flex\", justifyContent: \"center\" }}&gt; &lt;Circle /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/CircleSizeProvider&gt; );}export default App;useReduceruseState → 상태관리라는 것을 할 수 있다useReducer → 상태관리를 조금 다른 방법으로 할 수 있다.import React, { useReducer } from \"react\";import logo from \"./logo.svg\";import \"./App.css\";// reducer: (현재 상태, '액션' 객체)를 받아서 -&gt; 새로운 상태를 반환// action: 업데이트를 위한 정보를 갖고 있다.// state: component에서 사용할 상태 자체를 의미// dispatch: '액션'을 발생시키는 함수const [state, dispatch] = useReducer(reducer, initialState);function reducer(state, action) { switch (action.type) { case \"INCREMENT\": return state + 1; case \"DECREMENT\": return state - 1; default: return state; }}function Counter() { const [number, dispatch] = useReducer(reducer, 0); const onIncrease = () =&gt; { dispatch({ type: \"INCREMENT\" }); }; const onDecrease = () =&gt; { dispatch({ type: \"DECREMENT\" }); }; return ( &lt;div&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={onIncrease}&gt;+1&lt;/button&gt; &lt;button onClick={onDecrease}&gt;-1&lt;/button&gt; &lt;/div&gt; );}function App() { return ( &lt;div className=\"App\"&gt; &lt;Counter /&gt; &lt;/div&gt; );}export default App;useReducer 장점 코드의 가독성이 올라간다 다양한 케이스에 대해 대응이 가능해진다 단점 코드의 길이가 늘어난다 그렇다면 useState와 useReducer 중에 뭘 쓰면 좋을까?각자 상황, 구현하고자는 컴포넌트의 구조에 따라 다르겠지만 대체적으로→ useState: 컴포넌트에서 관리하는 값이 적고, 구조가 단순한 경우→ useReducer: 상태의 구조가 복잡할 때 사용하면 유리하다" }, { "title": "🌀 3/8 TS - 점진적으로 적용하기 (3)", "url": "/posts/TIL-ts-apply-third/", "categories": "TIL", "tags": "typescript", "date": "2022-03-08 09:32:00 +0900", "snippet": " 일단 any로 설정을 해둔 후, 조금 더 적절한 타입으로 바꿔나가기 string, any 등도 가능하지만 타입의 값이 한정된 경우, 직접 타입 선언하는 것도 좋다 enum CovidStatus {\tConfirmed = 'confirmed',\tDeaths = 'deaths',\tRecovered = 'recovered'}const fetchCovidCountry(id: string, status: CovidStatus): string { //...} new Date(), getTime() 등과 같은 내장 js 라이브러리 같은 경우는 자동으로 타입이 추론된다." }, { "title": "🌀 3/7 TS - 점진적으로 적용하기 (2) - JSDoc으로 js에서 type check하기", "url": "/posts/TIL-ts-apply-second/", "categories": "TIL", "tags": "typescript", "date": "2022-03-07 10:55:00 +0900", "snippet": "순수 js코드에 다음과 같은 주석을 추가하면 type 체크가 가능하다.// @ts-check이는 JSDoc을 이용하면 타입에 대한 힌트를 제공할 수 있다JSDoc이란?자바스크립트 API 문서 생성기로, API를 설명하는 HTML을 생성할 수 있다. 일반 주석과 마찬가지로 무시됌.1 변수타입/** * @type {string} */let str;2 함수타입// TypeScript syntax를 사용하는 방법/** * @type {(a:number, b: number) =&gt; number} */const add = (a, b) =&gt; a + b;// Closure syntax를 사용하는 방법/** * @type {function(number, number): number} */const multiply = (a, b) =&gt; a * b;/** * @param {string} p1 - A string of param * @param {string=} p2 - An optional param(Closure syntax) * @param {string} [p3] - Another optional param (JSDoc syntax) * @param {string} [p4=\"test\"] - An optional param with a default value * @return {string} This is the result */function stringsStringStrings(p1, p2, p3, p4) { //...}3 타입 정의 - 복잡한 타입을 정의할 때 사용한다/** * 할 일 * @typedef {Object} Todo * @property {number} id - 할일 id * @property {string} content - 할일 내용 * @property {boolean} completed - 할일 완료 여부 *//** * 할일 목록 * @typedef {Todo[]} */const todos = [ { id: 1, content: \"HTML\", completed: false }, { id: 2, content: \"CSS\", completed: true },]; 4 @callback @typedef와 유사하지만 object 타입 대신 특정한 function 타입을 지정한다." }, { "title": "🌀 3/7 TS - 점진적으로 적용하기 (1)", "url": "/posts/TIL-ts-apply/", "categories": "TIL", "tags": "typescript", "date": "2022-03-07 10:32:00 +0900", "snippet": "JS 코드에 TS를 적용할 때 주의할 점 기능적인 변경은 절대 X 테스트 커버리지가 낮을 땐 함부로 ts 적용하지 말 것 점진적으로 strict 레벨을 증가시킬 것 (처음부터 엄격하게 타입 적용 x)TS를 점진적으로 적용하는 방법( 0. 순수 JS : JSDoc을 이용해 순수 JS 코드에 힌트를 제공하기 ) ts 환경 설정 및 .ts 파일로 변환 any 타입 선언 any 타입을 더 적절한 타입으로 변경1. typescript 프로젝트 환경 구성 프로젝트 생성 후 npm init -y 로 package.json 생성 npm i typescript -D 로 타입스크립트 라이브러리 생성 타입스크립트 설정파일 tsconfig.json을 생성하고 기본값 추가하기 { \"compilerOptions\": { \"allowJs\": true, \"target\": \"ES5\", \"outDir\": \"./dist\", \"moduleResolution\": \"Node\", \"lib\": [\"ES2015\", \"DOM\", \"DOM.Iterable\"] }, \"include\": [\"./src/**/*\"], \"exclude\": [\"node_modules\", \"dist\"]} 서비스 코드가 포함된 .js → .ts 로 변환 (app.js → app.ts) 타입스크립트 컴파일 명렁어 tsc 로 타입스크립트 파일을 자바스크립트 파일로 변환하기2. 엄격하지 않은 타입 환경(loose type)에서 프로젝트 돌려보기 테스트 코드가 있다면 테스트 코드가 통과하는지 먼저 확인 모든 js 파일 → ts 파일 컴파일 에러 나는 것들 위주로만 에러 잡기 (여기서 기능을 사소하게라도 변경하지 않도록 주의) 테스트 코드가 성공하는지 확인3. 명시적인 any 선언하기 타입스크립트 설정파일에 noImplicitAny: true 추가하기 가능한 타입을 적용할 수 있는 모든 곳에 타입을 적용하기 library를 쓰는 경우 DefinitelyTyped에서 @types 관련 라이브러리를 찾아 설치한다. 타입을 정하기 어려운 곳이 있으면 명시적으로라도 any 선언하기4. strict 모드 설정하기 타입스크립트 설정 파일에 아래 설정을 추가한다{ \"strict\": true, \"strictNullChecks\": true, \"strictFunctionTypes\": true, \"strictBindCallApply\": true, \"strictPropertyInitialization\": true, \"noImplicitThis\": true, \"alwaysStrict\": true,} any로 되어있는 타입을 최대한 더 적절한 타입으로 변환 as 와 같은 키워드를 최대한 사용하지 않도록 고민해서 변경한다Q. 테스트코드 작성reference" }, { "title": "☀️ 3/6 - To check truthy value - if(var)", "url": "/posts/TIL-check-existcopy/", "categories": "TIL", "tags": "javascript", "date": "2022-03-06 10:50:00 +0900", "snippet": "if (value) { //true if value is not null, undefined, NaN, empty string(\"\"), 0, false}falsy value in Javascript false 0 null undefined NaNif(var)(내가 보려고 기록함)" }, { "title": "☀️ 3/6 - Object.assign()", "url": "/posts/TIL-object-assign/", "categories": "TIL", "tags": "javascript", "date": "2022-03-06 10:32:00 +0900", "snippet": "객체 복사 by Object.assign()같은 속성(key)가 있다면, 새로운 값으로 덮어쓰고, 아니라면 새로 추가해서 복사한다.같은 레퍼런스를 같도록 만든다.const target = { a: 1, b: 2 };const object = { b: 4, c: 2 };const copy = Object.assign(target, object); //target값이 변화console.log(target); // {a:1, b:4, c:2}console.log(copy); // {a:1, b:4, c:2}console.log(target === copy); // true여러 개도 가능const target = { a: 1, b: 2 };const sources = [ { b: 4, c: 5 }, { b: 6, c: 7, d: 8 }, { b: 9, c: 10, d: 11 }, { b: 12, c: 13, d: 14, e: 15 },];Object.assign(target, ...sources);Object.assign(target, sources[0], sources[1], sources[2], sources[3]); //same//리스트를 그대로 assign한다면(X), index를 키로 갖는 속성을 새로 추가해버림깊은 복사는 이루어지지 않는다Spread 연산자와 비교{...obj}Object.assign({}, obj)기본적으로 아래와 위 코드는 동일하다다만, Objec.assign(obj1, obj2) 는 obj1의 원본값을 변화시키므로값이 동일한 다른 객체를 생성하려면 반드시 첫 번째 파라미터로 {} 빈 객체를 넘겨주어야 한다.따라서 불변성(immutability)를 유지하려면, spread 쓰는 것을 권장" }, { "title": "[python]파이썬으로 알고리즘문제를 풀어보았다", "url": "/posts/python-algorithm/", "categories": "Algorithm", "tags": "", "date": "2021-10-28 19:24:50 +0900", "snippet": "자바로 알고리즘 공부하다가 입력이 너무 긴게 이제서야 진절머리가 나서 파이썬으로 한 번 바꿔볼까?했지만 적응이 안된다는 그런 이야기…입력이 자바에 비해 아주아주 간결해져서 신세계이긴한데 아직 파이썬이랑 낯가리는중1번. 백준 2468 - 안전영역import sysinput = sys.stdin.readlinen = int(input())mat = []for i in range(n): mat.append(list(map(int, input().split())))dx = [0,0,-1,1]dy = [-1,1,0,0]def bfs(sx, sy, visit, limit): visit[sx][sy] = True q = [] q.append([sx,sy]) while q: x, y = q.pop(0) for i in range(4): nx = x + dx[i] ny = y + dy[i] if nx&lt;0 or nx&gt;=n or ny&lt;0 or ny&gt;=n or visit[nx][ny]: continue if mat[nx][ny] &gt; limit: visit[nx][ny] = True q.append([nx, ny])ans=0rain = 0while True: cnt = 1 visit = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): if (not visit[i][j]) and mat[i][j] &gt; rain: bfs(i, j, visit, rain) cnt +=1 if cnt== 1: break ans = max(ans, cnt-1) rain +=1print(ans)2번. 백준 1399 - 단어수학n = int(input())ss = []alpha = [0] * 26for _ in range(n): ss.append(input())for s in ss: base = pow(10, len(s) - 1) for i in range(len(s)): alpha[ord(s[i]) - ord('A')] += int(base) base /= 10alpha.sort(reverse=True)ans = 0for i in range(9, 0, -1): ans += i * alpha[9-i]print(ans)…당분간은 섞어쓸 듯 하다" } ]
